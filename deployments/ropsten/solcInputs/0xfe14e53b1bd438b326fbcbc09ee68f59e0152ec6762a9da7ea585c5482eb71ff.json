{
  "language": "Solidity",
  "sources": {
    "contracts/Lottery.sol": {
      "content": "// Copyright (C) 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: GPL-3.0-only\n// This program is free software: you can redistribute it and/or modify it under\n// the terms of the GNU General Public License as published by the Free Software\n// Foundation, either version 3 of the License, or (at your option) any later\n// version.\n\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY\n// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n// PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n// Note: This component currently has dependencies that are licensed under the GNU\n// GPL, version 3, and so you should treat this component as a whole as being under\n// the GPL version 3. But all Cartesi-written code in this component is licensed\n// under the Apache License, version 2, or a compatible permissive license, and can\n// be used independently under the Apache v2 license. After this component is\n// rewritten, the entire component will be released under the Apache v2 license.\n\n/// @title Lottery\n/// @author Felipe Argento\n\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"@cartesi/util/contracts/CartesiMath.sol\";\nimport \"@cartesi/util/contracts/InstantiatorImpl.sol\";\nimport \"@cartesi/util/contracts/Decorated.sol\";\n\nimport \"./PrizeManager.sol\";\n\ncontract Lottery is InstantiatorImpl, Decorated, CartesiMath {\n    using SafeMath for uint256;\n\n    struct LotteryCtx {\n        mapping(uint256 => address) roundWinner; // each rounds winner\n        uint256 roundCount; // how many draw rounds happened\n        uint256 currentDrawStartTime; // timestamp of when current draw started\n        uint256 difficulty; // difficulty parameter defines how big the interval will be\n        uint256 difficultyAdjustmentParameter; // how fast the difficulty gets adjusted to reach the desired draw time, number * 1000000\n        uint256 desiredDrawTimeInterval; // desired draw time interval, used to tune difficulty\n        uint256 currentGoalBlockNumber; // block number which will decide current draw's goal\n\n        address posManagerAddress;\n\n    }\n\n    mapping(uint256 => LotteryCtx) internal instance;\n\n    event RoundClaimed(\n        address _winner,\n        uint256 _roundCount,\n        uint256 _roundDuration,\n        uint256 _difficulty\n    );\n\n    /// @notice Instantiates a Speed Bump structure\n    /// @param _difficultyAdjustmentParameter how quickly the difficulty gets updated\n    /// according to the difference between time passed and desired draw time interval.\n    /// @param _desiredDrawTimeInterval how often we want to elect a winner\n    /// @param _posManagerAddress address of ProofOfStake that will use this instance\n    function instantiate(\n        uint256 _difficultyAdjustmentParameter,\n        uint256 _desiredDrawTimeInterval,\n        address _posManagerAddress\n    ) public returns (uint256)\n    {\n        require(_desiredDrawTimeInterval > 30, \"Desired draw time interval has to be bigger than 30 seconds\");\n        instance[currentIndex].difficulty = 1000000;\n        instance[currentIndex].difficultyAdjustmentParameter = _difficultyAdjustmentParameter;\n        instance[currentIndex].desiredDrawTimeInterval = _desiredDrawTimeInterval;\n        instance[currentIndex].posManagerAddress = _posManagerAddress;\n\n        instance[currentIndex].currentGoalBlockNumber = block.number + 1; // goal has to be in the future, so miner cant manipulate (easily)\n        instance[currentIndex].currentDrawStartTime = block.timestamp; // first draw starts when the instance is created\n\n        active[currentIndex] = true;\n        return currentIndex++;\n    }\n\n    /// @notice Calculates the log of the random number between the goal and callers address\n    /// @param _index the index of the instance of lottery you want to interact with\n    /// @param _user address to calculate log of random\n    /// @return log of random number between goal and callers address * 1M\n    function getLogOfRandom(uint256 _index, address _user) internal view returns (uint256) {\n        bytes32 currentGoal = blockhash(instance[_index].currentGoalBlockNumber);\n        bytes32 hashedAddress = keccak256(abi.encodePacked(_user));\n        uint256 distance = uint256(keccak256(abi.encodePacked(hashedAddress, currentGoal)));\n\n        return CartesiMath.log2ApproxTimes1M(distance);\n    }\n\n    /// @notice Claim that _user won the round\n    /// @param _index the index of the instance of lottery you want to interact with\n    /// @param _user address that will win the lottery\n    /// @param _weight number that will weight the random number, most likely will be the number of staked tokens\n    function claimRound(uint256 _index, address _user, uint256 _weight) public returns (bool) {\n        LotteryCtx storage lot = instance[_index];\n\n        require(_weight > 0, \"Caller must have at least one staked token\");\n        require(msg.sender == lot.posManagerAddress, \"Function can only be called by pos address\");\n\n        uint256 timePassedMicroSeconds = ((block.timestamp).sub(lot.currentDrawStartTime)).mul(1000000); // time since draw started times 1e6 (microseconds)\n\n        if (canWin(_index, _user, _weight)) {\n            emit RoundClaimed(\n                _user,\n                lot.roundCount,\n                timePassedMicroSeconds,\n                lot.difficulty\n            );\n\n            return _roundFinished(_index, _user);\n        }\n\n        return false;\n    }\n\n    /// @notice Check if address can win current round\n    /// @param _index the index of the instance of lottery you want to interact with\n    /// @param _user the address that is gonna get checked\n    /// @param _weight number that will weight the random number, most likely will be the number of staked tokens\n    function canWin(uint256 _index, address _user, uint256 _weight) public view returns (bool) {\n        LotteryCtx storage lot = instance[_index];\n\n        uint256 timePassedMicroSeconds = ((block.timestamp).sub(lot.currentDrawStartTime)).mul(1000000); // time since draw started times 1e6 (microseconds)\n\n        // cannot get hash of block if its older than 256, we set 220 to avoid edge cases\n        // new goal cannot be in the past, otherwise user could \"choose it\"\n        return (block.number).sub(lot.currentGoalBlockNumber) > 220 || (_weight.mul(timePassedMicroSeconds)) > lot.difficulty.mul((256000000 - getLogOfRandom(_index, _user)));\n    }\n\n    /// @notice Finish Round, declare winner and ajust difficulty\n    /// @param _index the index of the instance of lottery you want to interact with\n    /// @param _user address of user that won the round\n    function _roundFinished(uint256 _index, address _user) private returns (bool) {\n        LotteryCtx storage lot = instance[_index];\n        // declare winner\n        lot.roundWinner[lot.roundCount] = _user;\n\n        // adjust difficulty\n        lot.difficulty = getNewDifficulty(\n            lot.difficulty,\n            (block.timestamp).sub(lot.currentDrawStartTime),\n            lot.desiredDrawTimeInterval,\n            lot.difficultyAdjustmentParameter\n        );\n\n        _reset(_index);\n        return true;\n    }\n\n    /// @notice Reset instance, advancing round and choosing new goal\n    /// @param _index the index of the instance of lottery you want to interact with\n    function _reset(uint256 _index) private {\n        LotteryCtx storage lot = instance[_index];\n\n        lot.roundCount++;\n        lot.currentGoalBlockNumber = block.number + 1;\n        lot.currentDrawStartTime = block.timestamp;\n    }\n\n    /// @notice Calculates new difficulty parameter\n    /// @param _oldDifficulty is the difficulty of previous round\n    /// @param _timePassed is how long the previous round took\n    /// @param _desiredDrawTime is how long a round is supposed to take\n    /// @param _adjustmentParam is how fast the difficulty gets adjusted, should be number * 1000000\n    function getNewDifficulty(uint256 _oldDifficulty, uint256 _timePassed, uint256 _desiredDrawTime, uint256 _adjustmentParam) internal pure returns (uint256) {\n        if (_timePassed < _desiredDrawTime) {\n            return _oldDifficulty.mul(_adjustmentParam).div(1000000) + 1;\n        } else if (_timePassed > _desiredDrawTime) {\n            return _oldDifficulty.mul(1000000).div(_adjustmentParam) + 1;\n        }\n\n        return _oldDifficulty;\n    }\n\n    function getState(uint256 _index, address _user)\n    public view returns (uint256[5] memory _uintValues) {\n        LotteryCtx storage i = instance[_index];\n\n        uint256[5] memory uintValues = [\n            block.number,\n            i.currentGoalBlockNumber,\n            i.difficulty,\n            ((block.timestamp).sub(i.currentDrawStartTime)).mul(1000000), // time passed\n            getLogOfRandom(_index, _user)\n        ];\n\n        return uintValues;\n    }\n\n    function isConcerned(uint256, address) public override pure returns (bool) {\n        return false; // isConcerned is only for the main concern (PoS)\n    }\n\n    function getSubInstances(uint256, address)\n        public override pure returns (address[] memory _addresses,\n            uint256[] memory _indices)\n    {\n        address[] memory a;\n        uint256[] memory i;\n\n        a = new address[](0);\n        i = new uint256[](0);\n\n        return (a, i);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@cartesi/util/contracts/CartesiMath.sol": {
      "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title CartesiMath\n/// @author Felipe Argento\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract CartesiMath {\n    using SafeMath for uint256;\n    mapping(uint256 => uint256) log2tableTimes1M;\n\n    constructor() {\n        log2tableTimes1M[1] = 0;\n        log2tableTimes1M[2] = 1000000;\n        log2tableTimes1M[3] = 1584962;\n        log2tableTimes1M[4] = 2000000;\n        log2tableTimes1M[5] = 2321928;\n        log2tableTimes1M[6] = 2584962;\n        log2tableTimes1M[7] = 2807354;\n        log2tableTimes1M[8] = 3000000;\n        log2tableTimes1M[9] = 3169925;\n        log2tableTimes1M[10] = 3321928;\n        log2tableTimes1M[11] = 3459431;\n        log2tableTimes1M[12] = 3584962;\n        log2tableTimes1M[13] = 3700439;\n        log2tableTimes1M[14] = 3807354;\n        log2tableTimes1M[15] = 3906890;\n        log2tableTimes1M[16] = 4000000;\n        log2tableTimes1M[17] = 4087462;\n        log2tableTimes1M[18] = 4169925;\n        log2tableTimes1M[19] = 4247927;\n        log2tableTimes1M[20] = 4321928;\n        log2tableTimes1M[21] = 4392317;\n        log2tableTimes1M[22] = 4459431;\n        log2tableTimes1M[23] = 4523561;\n        log2tableTimes1M[24] = 4584962;\n        log2tableTimes1M[25] = 4643856;\n        log2tableTimes1M[26] = 4700439;\n        log2tableTimes1M[27] = 4754887;\n        log2tableTimes1M[28] = 4807354;\n        log2tableTimes1M[29] = 4857980;\n        log2tableTimes1M[30] = 4906890;\n        log2tableTimes1M[31] = 4954196;\n        log2tableTimes1M[32] = 5000000;\n        log2tableTimes1M[33] = 5044394;\n        log2tableTimes1M[34] = 5087462;\n        log2tableTimes1M[35] = 5129283;\n        log2tableTimes1M[36] = 5169925;\n        log2tableTimes1M[37] = 5209453;\n        log2tableTimes1M[38] = 5247927;\n        log2tableTimes1M[39] = 5285402;\n        log2tableTimes1M[40] = 5321928;\n        log2tableTimes1M[41] = 5357552;\n        log2tableTimes1M[42] = 5392317;\n        log2tableTimes1M[43] = 5426264;\n        log2tableTimes1M[44] = 5459431;\n        log2tableTimes1M[45] = 5491853;\n        log2tableTimes1M[46] = 5523561;\n        log2tableTimes1M[47] = 5554588;\n        log2tableTimes1M[48] = 5584962;\n        log2tableTimes1M[49] = 5614709;\n        log2tableTimes1M[50] = 5643856;\n        log2tableTimes1M[51] = 5672425;\n        log2tableTimes1M[52] = 5700439;\n        log2tableTimes1M[53] = 5727920;\n        log2tableTimes1M[54] = 5754887;\n        log2tableTimes1M[55] = 5781359;\n        log2tableTimes1M[56] = 5807354;\n        log2tableTimes1M[57] = 5832890;\n        log2tableTimes1M[58] = 5857980;\n        log2tableTimes1M[59] = 5882643;\n        log2tableTimes1M[60] = 5906890;\n        log2tableTimes1M[61] = 5930737;\n        log2tableTimes1M[62] = 5954196;\n        log2tableTimes1M[63] = 5977279;\n        log2tableTimes1M[64] = 6000000;\n        log2tableTimes1M[65] = 6022367;\n        log2tableTimes1M[66] = 6044394;\n        log2tableTimes1M[67] = 6066089;\n        log2tableTimes1M[68] = 6087462;\n        log2tableTimes1M[69] = 6108524;\n        log2tableTimes1M[70] = 6129283;\n        log2tableTimes1M[71] = 6149747;\n        log2tableTimes1M[72] = 6169925;\n        log2tableTimes1M[73] = 6189824;\n        log2tableTimes1M[74] = 6209453;\n        log2tableTimes1M[75] = 6228818;\n        log2tableTimes1M[76] = 6247927;\n        log2tableTimes1M[77] = 6266786;\n        log2tableTimes1M[78] = 6285402;\n        log2tableTimes1M[79] = 6303780;\n        log2tableTimes1M[80] = 6321928;\n        log2tableTimes1M[81] = 6339850;\n        log2tableTimes1M[82] = 6357552;\n        log2tableTimes1M[83] = 6375039;\n        log2tableTimes1M[84] = 6392317;\n        log2tableTimes1M[85] = 6409390;\n        log2tableTimes1M[86] = 6426264;\n        log2tableTimes1M[87] = 6442943;\n        log2tableTimes1M[88] = 6459431;\n        log2tableTimes1M[89] = 6475733;\n        log2tableTimes1M[90] = 6491853;\n        log2tableTimes1M[91] = 6507794;\n        log2tableTimes1M[92] = 6523561;\n        log2tableTimes1M[93] = 6539158;\n        log2tableTimes1M[94] = 6554588;\n        log2tableTimes1M[95] = 6569855;\n        log2tableTimes1M[96] = 6584962;\n        log2tableTimes1M[97] = 6599912;\n        log2tableTimes1M[98] = 6614709;\n        log2tableTimes1M[99] = 6629356;\n        log2tableTimes1M[100] = 6643856;\n        log2tableTimes1M[101] = 6658211;\n        log2tableTimes1M[102] = 6672425;\n        log2tableTimes1M[103] = 6686500;\n        log2tableTimes1M[104] = 6700439;\n        log2tableTimes1M[105] = 6714245;\n        log2tableTimes1M[106] = 6727920;\n        log2tableTimes1M[107] = 6741466;\n        log2tableTimes1M[108] = 6754887;\n        log2tableTimes1M[109] = 6768184;\n        log2tableTimes1M[110] = 6781359;\n        log2tableTimes1M[111] = 6794415;\n        log2tableTimes1M[112] = 6807354;\n        log2tableTimes1M[113] = 6820178;\n        log2tableTimes1M[114] = 6832890;\n        log2tableTimes1M[115] = 6845490;\n        log2tableTimes1M[116] = 6857980;\n        log2tableTimes1M[117] = 6870364;\n        log2tableTimes1M[118] = 6882643;\n        log2tableTimes1M[119] = 6894817;\n        log2tableTimes1M[120] = 6906890;\n        log2tableTimes1M[121] = 6918863;\n        log2tableTimes1M[122] = 6930737;\n        log2tableTimes1M[123] = 6942514;\n        log2tableTimes1M[124] = 6954196;\n        log2tableTimes1M[125] = 6965784;\n        log2tableTimes1M[126] = 6977279;\n        log2tableTimes1M[127] = 6988684;\n        log2tableTimes1M[128] = 7000000;\n    }\n\n    /// @notice Approximates log2 * 1M\n    /// @param _num number to take log2 * 1M of\n    function log2ApproxTimes1M(uint256 _num) public view returns (uint256) {\n        require (_num > 0, \"Number cannot be zero\");\n        uint256 leading = 0;\n\n        if (_num == 1) return 0;\n\n        while (log2tableTimes1M[_num] == 0) {\n           _num = _num >> 1;\n           leading += 1;\n       }\n       return (leading.mul(uint256(1000000))).add(log2tableTimes1M[_num]);\n    }\n}\n"
    },
    "@cartesi/util/contracts/InstantiatorImpl.sol": {
      "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity ^0.7.0;\n\nimport \"./Instantiator.sol\";\n\nabstract contract InstantiatorImpl is Instantiator {\n    uint256 public currentIndex = 0;\n\n    mapping(uint256 => bool) internal active;\n    mapping(uint256 => uint256) internal nonce;\n\n    modifier onlyInstantiated(uint256 _index) override {\n        require(currentIndex > _index, \"Index not instantiated\");\n        _;\n    }\n\n    modifier onlyActive(uint256 _index) override {\n        require(currentIndex > _index, \"Index not instantiated\");\n        require(isActive(_index), \"Index inactive\");\n        _;\n    }\n\n    modifier increasesNonce(uint256 _index) override {\n        nonce[_index]++;\n        _;\n    }\n\n    function isActive(uint256 _index) public override view returns (bool) {\n        return (active[_index]);\n    }\n\n    function getNonce(uint256 _index)\n        public\n        override\n        view\n        onlyActive(_index)\n        returns (uint256 currentNonce)\n    {\n        return nonce[_index];\n    }\n\n    function deactivate(uint256 _index) public override {\n        active[_index] = false;\n        nonce[_index] = 0;\n    }\n}\n"
    },
    "@cartesi/util/contracts/Instantiator.sol": {
      "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n\npragma solidity ^0.7.0;\n\n\ninterface Instantiator {\n\n    modifier onlyInstantiated(uint256 _index) virtual;\n\n    modifier onlyActive(uint256 _index) virtual;\n\n    modifier increasesNonce(uint256 _index) virtual;\n\n    function isActive(uint256 _index) external view returns (bool);\n\n    function getNonce(uint256 _index) external view returns (uint256);\n\n    function isConcerned(uint256 _index, address _user) external view returns (bool);\n\n    function getSubInstances(uint256 _index, address) external view returns (address[] memory _addresses, uint256[] memory _indices);\n\n    function deactivate(uint256 _index) external;\n}\n"
    },
    "@cartesi/util/contracts/Decorated.sol": {
      "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity ^0.7.0;\n\n\ncontract Decorated {\n    // This contract defines several modifiers but does not use\n    // them - they will be used in derived contracts.\n    modifier onlyBy(address user) {\n        require(msg.sender == user, \"Cannot be called by user\");\n        _;\n    }\n\n    modifier onlyAfter(uint256 time) {\n        require(block.timestamp > time, \"Cannot be called now\");\n        _;\n    }\n}\n"
    },
    "contracts/PrizeManager.sol": {
      "content": "// Copyright (C) 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: GPL-3.0-only\n// This program is free software: you can redistribute it and/or modify it under\n// the terms of the GNU General Public License as published by the Free Software\n// Foundation, either version 3 of the License, or (at your option) any later\n// version.\n\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY\n// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n// PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n// Note: This component currently has dependencies that are licensed under the GNU\n// GPL, version 3, and so you should treat this component as a whole as being under\n// the GPL version 3. But all Cartesi-written code in this component is licensed\n// under the Apache License, version 2, or a compatible permissive license, and can\n// be used independently under the Apache v2 license. After this component is\n// rewritten, the entire component will be released under the Apache v2 license.\n\n/// @title PrizeManager\n/// @author Felipe Argento\n\n\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract PrizeManager {\n    using SafeMath for uint256;\n\n    uint256 minimumPrize;\n    uint256 distNumerator;\n    uint256 distDenominator;\n    address operator;\n    IERC20 ctsi;\n\n    event WinnerPaid(address _winner, uint256 _prize);\n\n    /// @notice Creates contract\n    /// @param _operator address of the operator\n    /// @param _ctsiAddress address of token instance being used\n    /// @param _minimumPrize minimum prize that this contract pays\n    /// @param _distNumerator multiplier factor to define prize amount\n    /// @param _distDenominator dividing factor to define prize amount\n    constructor(\n        address _operator,\n        address _ctsiAddress,\n        uint256 _minimumPrize,\n        uint256 _distNumerator,\n        uint256 _distDenominator\n    ) {\n\n        operator = _operator;\n        ctsi = IERC20(_ctsiAddress);\n\n        minimumPrize = _minimumPrize;\n        distNumerator = _distNumerator;\n        distDenominator = _distDenominator;\n    }\n\n    /// @notice Transfers token to winner of Lottery\n    /// @param _winner address of round winner\n    /// @dev only the pos contract can call this\n    function payWinner(address _winner, uint256 _amount) public {\n        require(msg.sender == operator, \"Only the operator contract can call this function\");\n\n        ctsi.transfer(_winner, _amount);\n\n        emit WinnerPaid(_winner, _amount);\n    }\n\n    /// @notice Get PrizeManager's balance\n    function getBalance() public view returns (uint256) {\n        return ctsi.balanceOf(address(this));\n    }\n\n    /// @notice Get prize of next Lottery round\n    function getCurrentPrize() public view returns (uint256) {\n        uint256 prize = (getBalance().mul(distNumerator)).div(distDenominator);\n        prize = prize > minimumPrize? prize : minimumPrize;\n\n        return prize > getBalance()? getBalance() : prize;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/PoS.sol": {
      "content": "// Copyright (C) 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: GPL-3.0-only\n// This program is free software: you can redistribute it and/or modify it under\n// the terms of the GNU General Public License as published by the Free Software\n// Foundation, either version 3 of the License, or (at your option) any later\n// version.\n\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY\n// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n// PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n// Note: This component currently has dependencies that are licensed under the GNU\n// GPL, version 3, and so you should treat this component as a whole as being under\n// the GPL version 3. But all Cartesi-written code in this component is licensed\n// under the Apache License, version 2, or a compatible permissive license, and can\n// be used independently under the Apache v2 license. After this component is\n// rewritten, the entire component will be released under the Apache v2 license.\n\n/// @title Proof of Stake\n/// @author Felipe Argento\n\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n\nimport \"@cartesi/util/contracts/CartesiMath.sol\";\nimport \"@cartesi/util/contracts/InstantiatorImpl.sol\";\nimport \"@cartesi/util/contracts/Decorated.sol\";\nimport \"@cartesi/util/contracts/WorkerAuthManager.sol\";\n\n\nimport \"./Staking.sol\";\nimport \"./Lottery.sol\";\nimport \"./PrizeManager.sol\";\n\ncontract PoS is Ownable, InstantiatorImpl, Decorated, CartesiMath {\n    using SafeMath for uint256;\n\n    uint256 constant SPLIT_BASE = 10000;\n\n    struct PoSCtx {\n        mapping (address => address) beneficiaryMap;\n        mapping (address => uint256) splitMap;\n        uint256 lotteryIndex;\n        Lottery lottery;\n        Staking staking;\n        PrizeManager prizeManager;\n        WorkerAuthManager workerAuth;\n    }\n\n    mapping(uint256 => PoSCtx) internal instance;\n\n    event BeneficiaryAdded(\n        uint256 indexed _index,\n        address indexed _user,\n        address indexed _beneficiary,\n        uint256 _split\n    );\n\n    function addBeneficiary(\n        uint256 _index,\n        address _beneficiary,\n        uint256 _split\n    ) public\n    {\n        PoSCtx storage pos = instance[_index];\n\n        require(\n            _split <= SPLIT_BASE,\n            \"split has to be less than 100%\"\n        );\n\n        pos.beneficiaryMap[msg.sender] = _beneficiary;\n        pos.splitMap[msg.sender] = SPLIT_BASE.sub(_split);\n\n        emit BeneficiaryAdded(\n            _index,\n            msg.sender,\n            _beneficiary,\n            _split\n        );\n    }\n\n    /// @notice Instantiates a Proof of Stake\n    /// @param _stakingAddress address of StakingInterface\n    /// @param _lotteryAddress address of lottery contract\n    /// @param _workerAuthAddress address of worker manager contract\n    /// @param _difficultyAdjustmentParameter how quickly the difficulty gets updated\n    /// according to the difference between time passed and desired draw time interval.\n    /// @param _desiredDrawTimeInterval how often we want to elect a winner\n    /// @param _prizeManagerAddress address containing the tokens that will be distributed\n    function instantiate(\n        address _stakingAddress,\n        address _lotteryAddress,\n        address _workerAuthAddress,\n        uint256 _difficultyAdjustmentParameter,\n        uint256 _desiredDrawTimeInterval,\n        address _prizeManagerAddress\n    ) public onlyOwner() returns (uint256)\n    {\n\n        instance[currentIndex].staking = Staking(_stakingAddress);\n        instance[currentIndex].lottery = Lottery(_lotteryAddress);\n        instance[currentIndex].prizeManager = PrizeManager(_prizeManagerAddress);\n        instance[currentIndex].workerAuth = WorkerAuthManager(_workerAuthAddress);\n\n        instance[currentIndex].lotteryIndex = instance[currentIndex].lottery.instantiate(\n            _difficultyAdjustmentParameter,\n            _desiredDrawTimeInterval,\n            address(this)\n        );\n\n        active[currentIndex] = true;\n        return currentIndex++;\n    }\n\n    /// @notice Claim that _user won the round\n    /// @param _index the index of the instance of pos you want to interact with\n    /// @dev this function can only be called by a worker, user never calls it directly\n    function claimWin(uint256 _index) public returns (bool) {\n\n        PoSCtx storage pos = instance[_index];\n\n        require(\n            pos.workerAuth.isAuthorized(msg.sender, address(this)),\n            \"msg.sender is not authorized to make this call\"\n        );\n\n        address user = pos.workerAuth.getOwner(msg.sender);\n        address beneficiary = pos.beneficiaryMap[user];\n\n        uint256 userSplit = pos.splitMap[user];\n        uint256 beneficiarySplit = SPLIT_BASE.sub(userSplit);\n\n        require(\n            pos.lottery.claimRound(pos.lotteryIndex, user, pos.staking.getStakedBalance(user)),\n            \"User couldnt claim round successfully\"\n        );\n\n        uint256 currentPrize = pos.prizeManager.getCurrentPrize();\n\n        if (beneficiary == address(0) || userSplit == SPLIT_BASE) {\n            pos.prizeManager.payWinner(user, currentPrize);\n        } else if (beneficiarySplit == SPLIT_BASE) {\n            pos.prizeManager.payWinner(beneficiary, currentPrize);\n        } else {\n            uint256 bSplit = currentPrize.mul(beneficiarySplit).div(SPLIT_BASE);\n            uint256 uSplit = SPLIT_BASE.sub(bSplit);\n\n            pos.prizeManager.payWinner(beneficiary, bSplit);\n            pos.prizeManager.payWinner(user, uSplit);\n        }\n\n        return true;\n    }\n\n    /// @notice Get state of a particular instance\n    /// @param _index index of instance\n    /// @return bool if user is eligible to produce next block\n    /// @return address of user that was chosen to build the block\n    /// @return current prize paid by the network for that block\n    /// @return percentage of prize that goes to the user\n    function getState(uint256 _index, address)\n    public\n    view\n    returns (\n        bool,\n        address,\n        uint256,\n        uint256\n    )\n    {\n        PoSCtx storage pos = instance[_index];\n\n        // translate worker/user address\n        address user = pos.workerAuth.getOwner(msg.sender);\n\n        return (\n            pos.lottery.canWin(\n                pos.lotteryIndex,\n                user,\n                pos.staking.getStakedBalance(user)\n            ),\n            user,\n            pos.prizeManager.getCurrentPrize(),\n            pos.splitMap[user]\n        );\n    }\n\n    function isConcerned(uint256 _index, address) public override view returns (bool) {\n        PoSCtx storage pos = instance[_index];\n\n        // translate worker/user address\n        address user = pos.workerAuth.getOwner(msg.sender);\n\n        return pos.staking.getStakedBalance(user) > 0;\n    }\n\n    function getSubInstances(uint256 _index, address)\n        public override view returns (address[] memory _addresses,\n            uint256[] memory _indices)\n    {\n        PoSCtx storage pos = instance[_index];\n\n        address[] memory a;\n        uint256[] memory i;\n\n        a = new address[](1);\n        i = new uint256[](1);\n\n        a[0] = address(pos.lottery);\n        i[0] = pos.lotteryIndex;\n        return (a, i);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@cartesi/util/contracts/WorkerAuthManager.sol": {
      "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title WorkerAuthManager\n/// @author Danilo Tuler\npragma solidity ^0.7.0;\n\ninterface WorkerAuthManager {\n    /// @notice Gives worker permission to act on a DApp\n    /// @param _workerAddress address of the worker node to given permission\n    /// @param _dappAddress address of the dapp that permission will be given to\n    function authorize(address _workerAddress, address _dappAddress) external;\n\n    /// @notice Removes worker's permission to act on a DApp\n    /// @param _workerAddress address of the proxy that will lose permission\n    /// @param _dappAddresses addresses of dapps that will lose permission\n    function deauthorize(address _workerAddress, address _dappAddresses)\n        external;\n\n    /// @notice Returns is the dapp is authorized to be called by that worker\n    /// @param _workerAddress address of the worker\n    /// @param _dappAddress address of the DApp\n    function isAuthorized(address _workerAddress, address _dappAddress)\n        external\n        view\n        returns (bool);\n\n    /// @notice Get the owner of the worker node\n    /// @param workerAddress address of the worker node\n    function getOwner(address workerAddress) external view returns (address);\n\n    /// @notice A DApp has been authorized by a user for a worker\n    event Authorization(\n        address indexed user,\n        address indexed worker,\n        address indexed dapp\n    );\n\n    /// @notice A DApp has been deauthorized by a user for a worker\n    event Deauthorization(\n        address indexed user,\n        address indexed worker,\n        address indexed dapp\n    );\n}\n"
    },
    "contracts/Staking.sol": {
      "content": "// Copyright (C) 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: GPL-3.0-only\n// This program is free software: you can redistribute it and/or modify it under\n// the terms of the GNU General Public License as published by the Free Software\n// Foundation, either version 3 of the License, or (at your option) any later\n// version.\n\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY\n// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n// PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n// Note: This component currently has dependencies that are licensed under the GNU\n// GPL, version 3, and so you should treat this component as a whole as being under\n// the GPL version 3. But all Cartesi-written code in this component is licensed\n// under the Apache License, version 2, or a compatible permissive license, and can\n// be used independently under the Apache v2 license. After this component is\n// rewritten, the entire component will be released under the Apache v2 license.\n\n\n/// @title Interface staking contract\npragma solidity ^0.7.0;\n\ninterface Staking {\n\n    /// @notice Returns total amount of tokens counted as stake\n    /// @param _userAddress user to retrieve staked balance from\n    /// @return finalized staked of _userAddress\n    function getStakedBalance(\n        address _userAddress) external view returns (uint256);\n\n    /// @notice Returns the timestamp when next deposit can be finalized\n    /// @return timestamp of when finalizeStakes() is callable\n    function getMaturingTimestamp(address _userAddress) external view returns (uint256);\n\n    /// @notice Returns the timestamp when next withdraw can be finalized\n    /// @return timestamp of when finalizeWithdraw() is callable\n    function getReleasingTimestamp(address _userAddress) external view returns (uint256);\n\n\n    /// @notice Returns the balance waiting/ready to be matured\n    /// @return amount that will get staked after finalization\n    function getMaturingBalance(address _userAddress) external view  returns (uint256);\n\n    /// @notice Returns the balance waiting/ready to be released\n    /// @return amount that will get withdrew after finalization\n    function getReleasingBalance(address _userAddress) external view  returns (uint256);\n\n\n    /// @notice Deposit CTSI to be staked. The money will turn into staked\n    ///         balance after timeToStake days\n    /// @param _amount The amount of tokens that are gonna be deposited.\n    function stake(uint256 _amount) external;\n\n    /// @notice Remove tokens from staked balance. The money can\n    ///         be released after timeToRelease seconds, if the\n    ///         function withdraw is called.\n    /// @param _amount The amount of tokens that are gonna be unstaked.\n    function unstake(uint256 _amount) external;\n\n    /// @notice Transfer tokens to user's wallet.\n    /// @param _amount The amount of tokens that are gonna be transferred.\n    function withdraw(uint256 _amount) external;\n\n    // events\n    /// @notice CTSI tokens were deposited, they count as stake after _maturationDate\n    /// @param _amount amount deposited for staking\n    /// @param _address address of msg.sender\n    /// @param _maturationDate date when the stake can be finalized\n    event Stake(\n        uint256 indexed _amount,\n        address indexed _address,\n        uint256 indexed _maturationDate\n    );\n\n    /// @notice Unstake tokens, moving them to releasing structure\n    /// @param _amount amount of tokens to be released\n    /// @param _address address of msg.sender\n    /// @param _maturationDate date when the tokens can be withdrew\n    event Unstake(\n        uint256 indexed _amount,\n        address indexed _address,\n        uint256 indexed _maturationDate\n    );\n\n    /// @notice Withdraw process was finalized\n    /// @param _amount amount of tokens withdrawn\n    /// @param _address address of msg.sender\n    event Withdraw(\n        uint256 indexed _amount,\n        address indexed _address\n    );\n}\n\n"
    },
    "contracts/StakingImpl.sol": {
      "content": "// Copyright (C) 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: GPL-3.0-only\n// This program is free software: you can redistribute it and/or modify it under\n// the terms of the GNU General Public License as published by the Free Software\n// Foundation, either version 3 of the License, or (at your option) any later\n// version.\n\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY\n// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n// PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n// Note: This component currently has dependencies that are licensed under the GNU\n// GPL, version 3, and so you should treat this component as a whole as being under\n// the GPL version 3. But all Cartesi-written code in this component is licensed\n// under the Apache License, version 2, or a compatible permissive license, and can\n// be used independently under the Apache v2 license. After this component is\n// rewritten, the entire component will be released under the Apache v2 license.\n\n\n/// @title Cartesi Staking\n/// @author Felipe Argento\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./Staking.sol\";\n\ncontract StakingImpl is Staking {\n    using SafeMath for uint256;\n    IERC20 private ctsi;\n\n    uint256 timeToStake; // time it takes for deposited tokens to become staked.\n    uint256 timeToRelease; // time it takes from witdraw signal to tokens to be unlocked.\n\n    mapping(address => uint256) staked; // amount of money being staked.\n    mapping(address => MaturationStruct) maturing; // deposits waiting to be staked.\n    mapping(address => MaturationStruct) releasing; // money waiting for withdraw.\n\n    struct MaturationStruct {\n        uint256 amount;\n        uint256 timestamp;\n    }\n\n    /// @notice constructor\n    /// @param _ctsiAddress address of compatible ERC20\n    /// @param _timeToStake time it takes for deposited tokens to become staked.\n    /// @param _timeToRelease time it takes from unstake to tokens being unlocked.\n    constructor(\n        address _ctsiAddress,\n        uint256 _timeToStake,\n        uint256 _timeToRelease\n    ) {\n        ctsi = IERC20(_ctsiAddress);\n        timeToStake = _timeToStake;\n        timeToRelease = _timeToRelease;\n    }\n\n    function stake(uint256 _amount) public override {\n        require(_amount > 0, \"amount cant be zero\");\n\n        // pointers to releasing/maturing structs\n        MaturationStruct storage r = releasing[msg.sender];\n        MaturationStruct storage m = maturing[msg.sender];\n\n        // check if there are mature coins to be staked\n        if (m.timestamp.add(timeToStake) <= block.timestamp) {\n            staked[msg.sender] = staked[msg.sender].add(m.amount);\n            m.amount = 0;\n        }\n\n        // first move tokens from releasing pool to maturing\n        // then transfer from wallet\n        if (r.amount >= _amount) {\n            r.amount = (r.amount).sub(_amount);\n        } else {\n            // transfer stake to contract\n            // from: msg.sender\n            // to: this contract\n            // value: _amount - releasing[msg.sender].amount\n            ctsi.transferFrom(msg.sender, address(this), _amount.sub(r.amount));\n            r.amount = 0;\n\n        }\n\n        m.amount = (m.amount).add(_amount);\n        m.timestamp = block.timestamp;\n\n        emit Stake(\n            m.amount,\n            msg.sender,\n            block.timestamp.add(timeToStake)\n        );\n    }\n\n    function unstake(uint256 _amount) public override {\n        require(_amount > 0, \"amount cant be zero\");\n\n        // pointers to releasing/maturing structs\n        MaturationStruct storage r = releasing[msg.sender];\n        MaturationStruct storage m = maturing[msg.sender];\n\n        if (m.amount >= _amount) {\n            m.amount = (m.amount).sub(_amount);\n        } else {\n            // safemath.sub guarantees that _amount <= m.amount + staked amount\n            staked[msg.sender] = staked[msg.sender].sub(_amount.sub(m.amount));\n            m.amount = 0;\n        }\n        // update releasing amount\n        r.amount = (r.amount).add(_amount);\n        r.timestamp = block.timestamp;\n\n        emit Unstake(\n            r.amount,\n            msg.sender,\n            block.timestamp.add(timeToRelease)\n        );\n    }\n\n    function withdraw(uint256 _amount) public override {\n        // pointer to releasing struct\n        MaturationStruct storage r = releasing[msg.sender];\n\n        require(_amount > 0, \"amount cant be zero\");\n        require(\n            r.timestamp.add(timeToRelease) <= block.timestamp,\n            \"tokens are not yet ready to be released\"\n        );\n\n        r.amount = (r.amount).sub(_amount, \"not enough tokens waiting to be released;\");\n\n        // withdraw tokens\n        // from: this contract\n        // to: msg.sender\n        // value: bet total withdraw value on toWithdraw\n        ctsi.transfer(msg.sender, _amount);\n        emit Withdraw(_amount, msg.sender);\n    }\n\n    // getters\n    function getMaturingTimestamp(\n        address _userAddress\n    )\n    public\n    view override\n    returns (uint256)\n    {\n        return maturing[_userAddress].timestamp.add(timeToStake);\n    }\n\n    function getMaturingBalance(\n        address _userAddress\n    )\n    public\n    view override\n    returns (uint256)\n    {\n        return maturing[_userAddress].amount;\n    }\n\n    function getReleasingBalance(\n        address _userAddress\n    )\n    public\n    view override\n    returns (uint256)\n    {\n        return releasing[_userAddress].amount;\n    }\n\n    function getReleasingTimestamp(\n        address _userAddress\n    )\n    public\n    view override\n    returns (uint256)\n    {\n        return releasing[_userAddress].timestamp.add(timeToRelease);\n    }\n\n    function getStakedBalance(address _userAddress)\n    public\n    view override\n    returns (uint256)\n    {\n        MaturationStruct storage m = maturing[_userAddress];\n\n        // if there are mature deposits, treat them as staked\n        if (m.timestamp.add(timeToStake) <= block.timestamp) {\n            return staked[_userAddress].add(m.amount);\n        }\n\n        return staked[_userAddress];\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}